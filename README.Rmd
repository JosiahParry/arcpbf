---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)

options(max.print = 100)
```

# arcpbf

`{arcpbf}` is an R package that processes Esri Protocol Buffers. It is written
in Rust and powered by the [extendr](https://github.com/extendr/extendr) library.

arcpbf has functions for reading protocol buffer (pbf) results from an ArcGIS 
REST API result. pbf results are returned when `f=pbf` in a [query](https://developers.arcgis.com/rest/services-reference/enterprise/query-feature-service-layer-.htm). 
The package is intended to be extremely lightweight and fast. As such, it has no 
hard dependencies. 

> ***Important***: Rust must be installed to compile the package. Run the one line 
installation instructions at https://rustup.rs/. To verify your Rust installation
is compatible, run `rextendr::rust_sitrep()`. That's it. 

## TL;DR 

- `open_pbf()` will read a FeatureCollection `pbf` file into a raw vector
- `read_pbf()` will read a FeatureCollection `pbf` file _and_ process it
- `process_pbf()` will process a raw vector or a list of raw vectors
- `post_process_pbf()` will apply post processing steps to the results of `process_pbf()`
  - set `use_sf = FALSE` to return a `data.frame` otherwise an `sf` object will be returned
- `multi_resp_process()` processes a list of `httr2_response` using `process_pbf()`
  - if an element is not a response or have a 200 status code, `NULL` is returned

## Basic usage 

There are two ways of processing a FeatureCollection pbf. We either can read
directly from a binary file (typically with a `.pbf` extension). Or, we process
the a raw vector containing the binary of a pbf as returned by an http request. 
These are accomplished with `read_pbf()` and `process_pbf()` respectively. 

Here we read a single pbf file. 

```{r}
library(arcpbf)

x <- read_pbf("inst/pbfs/pnts.pbf")
str(x, 1)
```

For pbf files containing geometries, we retrieve a list of 3 elements:

- `attributes` is a `data.frame` of the fields of the FeatureCollection
- `geometry` is a pseudo-sfc object (more on this later) which is a list of sfg geometry objects
- `sr` is a named list of the spatial reference of the feature collection

Whereas FeatureCollections _without geometries_ will always return a single data.frame.

```{r}
read_pbf("inst/pbfs/small-table.pbf")
```

These results use no external dependencies. If we want to convert the named list into a familiar sf object
we will have to **post-process** it using `post_process_pbf()`. The `use_sf` argument, which defaults 
to `TRUE`, will use the `sf` package to return an `sf` object. 

```{r}
post_process_pbf(x)
```

If it is set to `FALSE`, it will return a `data.frame`.

```{r}
post_process_pbf(x, use_sf = FALSE)
```


## Reading from a raw vector

The `open_pbf()` function will read a pbf file into a raw vector which can be 
passed to `process_pbf()`. In general you will not need this function, but it 
is handy for the sake of example. 

```{r}
pbf_raw <- open_pbf("inst/pbfs/big-pnts.pbf")
head(pbf_raw, 20)
```

This raw vector can be turned into an R object using `process_pbf()`.

```{r}
res <- process_pbf(pbf_raw)
str(res, 1)
```

## Processing requests 

The true purpose of this package is to process requests from the REST API. Here
we process a single request using [`{httr2}`](https://httr2.r-lib.org/)

```{r}

url <- "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/ACS_Population_by_Race_and_Hispanic_Origin_Boundaries/FeatureServer/2/query?where=1=1&outFields=*&f=pbf&token="

resp <- httr2::request(url) |> 
  httr2::req_perform() |> 
  httr2::resp_body_raw()

x <- process_pbf(resp)
```

In developing an R package, one may be creating multiple requests in parallel using `httr2::multi_req_perform()` as is done in [`{arcgislayers}`](https://github.com/R-ArcGIS/arcgislayers).

```{r}
reqs <- replicate(5, httr2::request(url), simplify = FALSE)

resps <- httr2::multi_req_perform(reqs)
```

We can process all of the responses using `multi_resp_process()` and pass the results to `post_process_pbf()`.

Note that when post processing a list of responses, `data.table::rbindlist()` will be used to bind
the results together. If data.table is not available, `dplyr::bind_rows()` will be used. If dplyr
is not available, rows will be bound together using `do.call(rbind.data.frame, x)`. 

```{r}
res <- multi_resp_process(resps) |> 
  post_process_pbf()

head(res)
```

## Benchmarking

Below is a bench mark that compares processing pbfs to the current approach of processing 
raw json in arcgislayers and arcgisutils. The below recreates the example from the README of
arcgislayers. 

```{r}
jsn <- function() {
  json_reqs <- c(
    "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Counties_Generalized_Boundaries/FeatureServer/0/query?outFields=%2A&where=1%3D1&outSR=%7B%22wkid%22%3A4326%7D&returnGeometry=TRUE&token=&f=json&resultOffset=0",
    "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Counties_Generalized_Boundaries/FeatureServer/0/query?outFields=%2A&where=1%3D1&outSR=%7B%22wkid%22%3A4326%7D&returnGeometry=TRUE&token=&f=json&resultOffset=2001"
  )
  reqs <- lapply(json_reqs, httr2::request) 
  
  httr2::multi_req_perform(reqs) |> 
    lapply(function(x) arcgisutils::parse_esri_json(httr2::resp_body_string(x))) |> 
    data.table::rbindlist() |> 
    sf::st_as_sf()
  
}

# protobuff processing 
pbf <- function() {
  
  pbf_reqs <- c(
    "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Counties_Generalized_Boundaries/FeatureServer/0/query?outFields=%2A&where=1%3D1&outSR=%7B%22wkid%22%3A4326%7D&returnGeometry=TRUE&token=&f=pbf&resultOffset=0",
    "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Counties_Generalized_Boundaries/FeatureServer/0/query?outFields=%2A&where=1%3D1&outSR=%7B%22wkid%22%3A4326%7D&returnGeometry=TRUE&token=&f=pbf&resultOffset=2001"
  )
  
  reqs <- lapply(pbf_reqs, httr2::request)
  
  httr2::multi_req_perform(reqs) |> 
    multi_resp_process() |> 
    post_process_pbf()
}

bench::mark(
  jsn(),
  pbf(),
  check = FALSE,
  relative = TRUE,
  iterations = 5
)
```


## Internals 

Internally, there is a rust crate [`esripbf`](./src/rust/esripbf) which is a
a Rust library built with [`prost`](https://github.com/tokio-rs/prost) to handle the [FeatureCollection Protocol Buffer Specification](https://github.com/Esri/arcgis-pbf/tree/main/proto/FeatureCollection).


## Notes

Alternatively, it may make sense to write to a geoarrow array and convert to sfc 
using {wk}. These are just thoughts. 
